import { EntireEncryption } from './EntireEncryption';
import { EncryptionKeyStatus } from '../sync/utils/EncryptInfo';
import { ErrorCode } from '../utils/ErrorCode';
import { NaturalBaseRef } from '../base/NaturalBaseRef';
export declare const SALT_SIZE = 16;
export declare const ENCODE_KEY_SIZE = 44;
export declare const TAG_SIZE = 16;
export declare const IV_SIZE = 12;
export declare const DATA_KEY_CIPHER_SIZE: number;
export interface CipherTextInfo {
    iv: Uint8Array;
    tag: Uint8Array;
    cipherText: Uint8Array;
}
export declare class SecretKeyManager {
    private userDataKeyInfo;
    private entireEncryption;
    private cloudStorage;
    private entireEncryptInterval;
    constructor(naturalBaseRef: NaturalBaseRef);
    getEntireEncryption(): EntireEncryption;
    setUserKey(userKey: string, needStrongCheck: boolean): Promise<void>;
    modifyUserKey(userKey: string, userReKey: string, needStrongCheck: boolean): Promise<void>;
    private verifyUserKey;
    private createUserKey;
    private modifyUserKeyInner;
    private queryDataKeyCipher;
    private reGenerateUserKey;
    private generateUserKey;
    onKeyStatusChanged(keyStatus: EncryptionKeyStatus): Promise<ErrorCode>;
    private queryDataKeyAfterReKey;
    checkKeyIfNetworkReconnect(): Promise<ErrorCode>;
    private processDataKeyChangedByReconnect;
    private refreshDataKeyCache;
    private decryptQueryCipherText;
    private saveDataKeyCipher;
    private saveUserDataKey;
    private getSaltFromCloud;
    private InsertEncryptionInfoToCloud;
    private queryDataKeyCipherFromCloud;
    private updateEncryptionInfoToCloud;
    private getUserId;
    private checkDataKeyCache;
    private checkUserKeyFormat;
    private encodeDataKey;
    generateRandom(num: number): Uint8Array;
    clearDataKeyInfo(): void;
    private clearOldDataKeyInfo;
}
