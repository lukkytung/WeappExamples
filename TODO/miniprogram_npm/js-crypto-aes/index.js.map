{"version":3,"sources":["index.js","aes.js","nodeapi.js","params.js","webapi.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA,ACHA;AFOA,ADGA,AENA,ACHA;AFOA,ADGA,AENA,ACHA;AFOA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n/**\n * index.js\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.unwrapKey = exports.wrapKey = exports.decrypt = exports.encrypt = void 0;\nvar aes = __importStar(require(\"./aes\"));\nexports.encrypt = aes.encrypt;\nexports.decrypt = aes.decrypt;\nexports.wrapKey = aes.wrapKey;\nexports.unwrapKey = aes.unwrapKey;\nexports.default = { encrypt: exports.encrypt, decrypt: exports.decrypt, wrapKey: exports.wrapKey, unwrapKey: exports.unwrapKey };\n//# sourceMappingURL=index.js.map","\n/**\n * aes.js\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.unwrapKey = exports.wrapKey = exports.decrypt = exports.encrypt = void 0;\nvar util = __importStar(require(\"js-crypto-env\"));\nvar nodeapi = __importStar(require(\"./nodeapi\"));\nvar webapi = __importStar(require(\"./webapi\"));\nvar params_1 = __importDefault(require(\"./params\"));\n/**\n * Check if the given algorithm spec is valid.\n * @param {String} name - Name of the specified algorithm like 'AES-GCM'.\n * @param {Uint8Array} iv - IV byte array if required\n * @param {Number} tagLength - Authentication tag length if required\n * @throws {Error} - Throws if UnsupportedAlgorithm, InvalidArguments, InvalidIVLength, or InvalidTagLength.\n */\nvar assertAlgorithms = function (_a) {\n    var name = _a.name, iv = _a.iv, tagLength = _a.tagLength;\n    if (params_1.default.ciphers[name].ivLength) {\n        if (!(iv instanceof Uint8Array))\n            throw new Error('InvalidArguments');\n        if (iv.byteLength < 2 || iv.byteLength > 16)\n            throw new Error('InvalidIVLength');\n        if (params_1.default.ciphers[name].staticIvLength && (params_1.default.ciphers[name].ivLength !== iv.byteLength))\n            throw new Error('InvalidIVLength');\n    }\n    if (params_1.default.ciphers[name].tagLength && tagLength) {\n        if (!Number.isInteger(tagLength))\n            throw new Error('InvalidArguments');\n        if (tagLength < 4 || tagLength > 16)\n            throw new Error('InvalidTagLength');\n    }\n};\n/**\n * Encrypt data with AES\n * @param {Uint8Array} msg - Message to be encrypted.\n * @param {Uint8Array} key - The symmetric key used to encrypt the message.\n * @param {String} [name = 'AES-GCM'] - Name of the specified algorithm like 'AES-GCM'.\n * @param {Uint8Array} [iv] - Byte array of the initial vector if required.\n * @param {Uint8Array} [additionalData = new Uint8Array([])] - Byte array of additional data if required.\n * @param {Number} [tagLength = params.ciphers[name].tagLength] - Authentication tag length if required.\n * @return {Promise<Uint8Array>} - Encrypted message.\n * @throws {Error} - Throws if InvalidArguments, FaildToEncryptWeb/Node, or UnsupportedEnvironment (no webcrypto/nodecrypto).\n */\nvar encrypt = function (msg, key, _a) {\n    var _b = _a.name, name = _b === void 0 ? 'AES-GCM' : _b, iv = _a.iv, _c = _a.additionalData, additionalData = _c === void 0 ? new Uint8Array([]) : _c, tagLength = _a.tagLength;\n    return __awaiter(void 0, void 0, void 0, function () {\n        var env;\n        return __generator(this, function (_d) {\n            // assertion and sanitizing\n            assertAlgorithms({ name: name, iv: iv, tagLength: tagLength });\n            if (params_1.default.ciphers[name].tagLength && !tagLength)\n                tagLength = params_1.default.ciphers[name].tagLength;\n            env = util.getCrypto();\n            if (env.name === 'webCrypto') { // for web API\n                if (typeof env.crypto.importKey !== 'function' || typeof env.crypto.encrypt !== 'function')\n                    throw new Error('UnsupportedWebCrypto');\n                return [2 /*return*/, webapi.encrypt(msg, key, { name: name, iv: iv, additionalData: additionalData, tagLength: tagLength }, env.crypto)];\n            }\n            else if (env.name === 'nodeCrypto') { // for node\n                return [2 /*return*/, nodeapi.encrypt(msg, key, { name: name, iv: iv, additionalData: additionalData, tagLength: tagLength }, env.crypto)];\n            }\n            else\n                throw new Error('UnsupportedEnvironment'); // TODO:fallback to native implementation\n            return [2 /*return*/];\n        });\n    });\n};\nexports.encrypt = encrypt;\n/**\n * Decrypt data with AES\n * @param {Uint8Array} data - Byte array of encrypted data.\n * @param {Uint8Array} key - Byte array of symmetric key to be used for decryption.\n * @param {String} [name = 'AES-GCM'] - Name of the specified algorithm like 'AES-GCM'.\n * @param {Uint8Array} [iv] - Byte array of the initial vector if required.\n * @param {Uint8Array} [additionalData = new Uint8Array([])] - Byte array of additional data if required.\n * @param {Number} [tagLength = params.ciphers[name].tagLength] - Authentication tag length if required.\n * @return {Promise<Uint8Array>} - Decrypted plaintext message.\n * @throws {Error} - Throws if InvalidArguments, FailedToDecryptWeb/Node, or UnsupportedEnvironment (no webcrypto/nodecrypto).\n */\nvar decrypt = function (data, key, _a) {\n    var _b = _a.name, name = _b === void 0 ? 'AES-GCM' : _b, iv = _a.iv, _c = _a.additionalData, additionalData = _c === void 0 ? new Uint8Array([]) : _c, tagLength = _a.tagLength;\n    return __awaiter(void 0, void 0, void 0, function () {\n        var env;\n        return __generator(this, function (_d) {\n            // assertion and sanitizing\n            assertAlgorithms({ name: name, iv: iv, tagLength: tagLength });\n            if (params_1.default.ciphers[name].tagLength && !tagLength)\n                tagLength = params_1.default.ciphers[name].tagLength;\n            env = util.getCrypto();\n            if (env.name === 'webCrypto') { // for web API\n                if (typeof env.crypto.importKey !== 'function' || typeof env.crypto.decrypt !== 'function')\n                    throw new Error('UnsupportedWebCrypto');\n                return [2 /*return*/, webapi.decrypt(data, key, { name: name, iv: iv, additionalData: additionalData, tagLength: tagLength }, env.crypto)];\n            }\n            else if (env.name === 'nodeCrypto') { // for node\n                return [2 /*return*/, nodeapi.decrypt(data, key, { name: name, iv: iv, additionalData: additionalData, tagLength: tagLength }, env.crypto)];\n            }\n            else\n                throw new Error('UnsupportedEnvironment');\n            return [2 /*return*/];\n        });\n    });\n};\nexports.decrypt = decrypt;\n/**\n * AES-KW wrapping\n * @param keyToBeWrapped {Uint8Array} - key bytes to be wrapped\n * @param wrappingKey {Uint8Array} - wrapping key encryption key\n * @param name {'AES-KW'} - this is simply for future extension\n * @return {Promise<Uint8Array>} - output wrapped key\n */\nvar wrapKey = function (keyToBeWrapped, wrappingKey, _a) {\n    var name = _a.name;\n    return __awaiter(void 0, void 0, void 0, function () {\n        var env, iv;\n        return __generator(this, function (_b) {\n            // assertion\n            if (keyToBeWrapped.length % 8 > 0)\n                throw new Error('WrappedKeyMustBeMultipleOf8');\n            env = util.getCrypto();\n            iv = (params_1.default.wrapKeys['AES-KW'].defaultIv);\n            if (env.name === 'webCrypto') { // for web API\n                if (typeof env.crypto.importKey !== 'function' || typeof env.crypto.wrapKey !== 'function')\n                    throw new Error('UnsupportedWebCrypto');\n                return [2 /*return*/, webapi.wrapKey(keyToBeWrapped, wrappingKey, { name: name, iv: iv }, env.crypto)];\n            }\n            else if (env.name === 'nodeCrypto') { // for node\n                return [2 /*return*/, nodeapi.wrapKey(keyToBeWrapped, wrappingKey, { name: name, iv: iv }, env.crypto)];\n            }\n            else {\n                throw new Error('UnsupportedEnvironment'); // TODO:fallback to native implementation\n            }\n            return [2 /*return*/];\n        });\n    });\n};\nexports.wrapKey = wrapKey;\n/**\n * AES-KW unwrapping\n * @param wrappedKey {Uint8Array} - wrapped key bytes\n * @param wrappingKey {Uint8Array} - wrapping key encryption key\n * @param name {'AES-KW'} - this is simply for future extension\n * @return {Promise<Uint8Array>} - output unwrapped key\n */\nvar unwrapKey = function (wrappedKey, wrappingKey, _a) {\n    var name = _a.name;\n    return __awaiter(void 0, void 0, void 0, function () {\n        var env, iv;\n        return __generator(this, function (_b) {\n            env = util.getCrypto();\n            iv = (params_1.default.wrapKeys['AES-KW'].defaultIv);\n            if (env.name === 'webCrypto') { // for web API\n                if (typeof env.crypto.importKey !== 'function' || typeof env.crypto.unwrapKey !== 'function')\n                    throw new Error('UnsupportedWebCrypto');\n                return [2 /*return*/, webapi.unwrapKey(wrappedKey, wrappingKey, { name: name, iv: iv }, env.crypto)];\n            }\n            else if (env.name === 'nodeCrypto') { // for node\n                return [2 /*return*/, nodeapi.unwrapKey(wrappedKey, wrappingKey, { name: name, iv: iv }, env.crypto)];\n            }\n            else {\n                throw new Error('UnsupportedEnvironment'); // TODO:fallback to native implementation\n            }\n            return [2 /*return*/];\n        });\n    });\n};\nexports.unwrapKey = unwrapKey;\n//# sourceMappingURL=aes.js.map","\n/**\n * nodeapi.js\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decrypt = exports.encrypt = exports.unwrapKey = exports.wrapKey = void 0;\nvar params_1 = __importDefault(require(\"./params\"));\n/**\n * Node.js KeyWrapping function simply uses encrypt function.\n * @param keyToBeWrapped {Uint8Array} - plaintext key\n * @param wrappingKey {Uint8Array} - wrapping key\n * @param name {string} - 'AES-KW'\n * @param iv {Uint8Array} - default is '0xA6A6A6A6A6A6A6A6'\n * @param nodeCrypto {Object} - NodeCrypto object\n * @return {Uint8Array} - Unwrapped Key\n */\nvar wrapKey = function (keyToBeWrapped, wrappingKey, _a, nodeCrypto) {\n    var name = _a.name, iv = _a.iv;\n    return (0, exports.encrypt)(keyToBeWrapped, wrappingKey, { name: name, iv: iv }, nodeCrypto, true);\n};\nexports.wrapKey = wrapKey;\n/**\n * Node.js KeyUnwrapping function as well as keyWrapping\n * @param wrappedKey {Uint8Array} - Wrapped key\n * @param unwrappingKey {Uint8Array} - Key used for wrapping\n * @param name {string} - 'AES-KW'\n * @param iv {Uint8Array} - default is '0xA6A6A6A6A6A6A6A6'\n * @param nodeCrypto {Object} - NodeCrypto object\n * @return {Uint8Array} - Unwrapped Key\n */\nvar unwrapKey = function (wrappedKey, unwrappingKey, _a, nodeCrypto) {\n    var name = _a.name, iv = _a.iv;\n    return (0, exports.decrypt)(wrappedKey, unwrappingKey, { name: name, iv: iv }, nodeCrypto, true);\n};\nexports.unwrapKey = unwrapKey;\n/**\n * Encrypt plaintext message via AES Node.js crypto API\n * @param {Uint8Array} msg - Plaintext message to be encrypted.\n * @param {Uint8Array} key - Byte array of symmetric key.\n * @param {String} name - Name of AES algorithm like 'AES-GCM'.\n * @param {Uint8Array} [iv] - Byte array of initial vector if required.\n * @param {Uint8Array} [additionalData] - Byte array of additional data if required.\n * @param {Number} [tagLength] - Authentication tag length if required.\n * @param {Object} nodeCrypto - NodeCrypto object, i.e., require(crypto) in Node.js.\n * @param wrapKey {Boolean} [false] - true if called as AES-KW\n * @return {Uint8Array} - Encrypted message byte array.\n * @throws {Error} - Throws error if UnsupportedCipher.\n */\nvar encrypt = function (msg, key, _a, nodeCrypto, wrapKey) {\n    var name = _a.name, iv = _a.iv, additionalData = _a.additionalData, tagLength = _a.tagLength;\n    if (wrapKey === void 0) { wrapKey = false; }\n    var alg = getNodeName(name, key.byteLength, (wrapKey) ? params_1.default.wrapKeys : params_1.default.ciphers);\n    var cipher;\n    switch (name) {\n        case 'AES-GCM': {\n            cipher = nodeCrypto.createCipheriv(alg, key, iv, { authTagLength: tagLength });\n            cipher.setAAD(additionalData);\n            break;\n        }\n        case 'AES-CTR': {\n            if (iv.length === 0 || iv.length > 16)\n                throw new Error('InvalidIVLength');\n            var counter = new Uint8Array(16);\n            counter.set(iv);\n            counter[15] += 1;\n            cipher = nodeCrypto.createCipheriv(alg, key, counter);\n            break;\n        }\n        default: { // AES-CBC or AES-KW\n            cipher = nodeCrypto.createCipheriv(alg, key, iv);\n            break;\n        }\n    }\n    var body;\n    var final;\n    var tag;\n    try {\n        body = new Uint8Array(cipher.update(msg));\n        final = new Uint8Array(cipher.final());\n        tag = new Uint8Array([]);\n        if (name === 'AES-GCM')\n            tag = new Uint8Array(cipher.getAuthTag());\n    }\n    catch (e) {\n        throw new Error('NodeCrypto_EncryptionFailure');\n    }\n    var data = new Uint8Array(body.length + final.length + tag.length);\n    data.set(body);\n    data.set(final, body.length);\n    data.set(tag, body.length + final.length);\n    return data;\n};\nexports.encrypt = encrypt;\n/**\n * Decrypt data through AES Node.js crypto API.\n * @param {Uint8Array} data - Encrypted message to be decrypted.\n * @param {Uint8Array} key - Byte array of symmetric key.\n * @param {String} name - Name of AES algorithm like 'AES-GCM'.\n * @param {Uint8Array} [iv] - Byte array of initial vector if required.\n * @param {Uint8Array} [additionalData] - Byte array of additional data if required.\n * @param {Number} [tagLength] - Authentication tag length if required.\n * @param {Object} nodeCrypto - NodeCrypto object, i.e., require(crypto) in Node.js.\n * @return {Uint8Array} - Decrypted message byte array.\n * @param unwrapKey {Boolean} [false] - true if called as AES-KW\n * @throws {Error} - Throws error if UnsupportedCipher or DecryptionFailure.\n */\nvar decrypt = function (data, key, _a, nodeCrypto, unwrapKey) {\n    var name = _a.name, iv = _a.iv, additionalData = _a.additionalData, tagLength = _a.tagLength;\n    if (unwrapKey === void 0) { unwrapKey = false; }\n    var alg = getNodeName(name, key.byteLength, (unwrapKey) ? params_1.default.wrapKeys : params_1.default.ciphers);\n    var decipher;\n    var body;\n    switch (name) {\n        case 'AES-GCM': {\n            decipher = nodeCrypto.createDecipheriv(alg, key, iv, { authTagLength: tagLength });\n            decipher.setAAD(additionalData);\n            body = data.slice(0, data.length - tagLength);\n            var tag = data.slice(data.length - tagLength);\n            decipher.setAuthTag(tag);\n            break;\n        }\n        case 'AES-CTR': {\n            if (iv.length === 0 || iv.length > 16)\n                throw new Error('InvalidIVLength');\n            var counter = new Uint8Array(16);\n            counter.set(iv);\n            counter[15] += 1;\n            decipher = nodeCrypto.createDecipheriv(alg, key, counter);\n            body = data;\n            break;\n        }\n        default: { // AES-CBC or AES-KW\n            decipher = nodeCrypto.createDecipheriv(alg, key, iv);\n            body = data;\n            break;\n        }\n    }\n    var decryptedBody;\n    var final;\n    try {\n        decryptedBody = decipher.update(body);\n        final = decipher.final();\n    }\n    catch (e) {\n        throw new Error('NodeCrypto_DecryptionFailure');\n    }\n    var msg = new Uint8Array(final.length + decryptedBody.length);\n    msg.set(decryptedBody);\n    msg.set(final, decryptedBody.length);\n    return msg;\n};\nexports.decrypt = decrypt;\n/**\n * get node algorithm name\n * @param name {string} - name of webcrypto alg like AES-GCM\n * @param keyLength {number} - aes encryption key\n * @param dict {object} - params.ciphers or params.wrapKeys\n * @return {string} - node algorithm name\n */\nvar getNodeName = function (name, keyLength, dict) {\n    var alg = dict[name].nodePrefix;\n    alg = \"\".concat(alg).concat((keyLength * 8).toString());\n    return alg + dict[name].nodeSuffix;\n};\n//# sourceMappingURL=nodeapi.js.map","\n/**\n * params.js\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ciphers = {\n    'AES-GCM': {\n        nodePrefix: 'aes-',\n        nodeSuffix: '-gcm',\n        ivLength: 12,\n        tagLength: 16,\n        staticIvLength: true, // if true, IV length must be always ivLength.\n    },\n    'AES-CBC': {\n        nodePrefix: 'aes-',\n        nodeSuffix: '-cbc',\n        ivLength: 16,\n        staticIvLength: true,\n    },\n    'AES-CTR': {\n        nodePrefix: 'aes-',\n        nodeSuffix: '-ctr',\n        ivLength: 12,\n        staticIvLength: false,\n    }\n};\nvar wrapKeys = {\n    'AES-KW': {\n        nodePrefix: 'id-aes',\n        nodeSuffix: '-wrap',\n        ivLength: 8,\n        staticIvLength: true,\n        defaultIv: new Uint8Array([0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6])\n    }\n};\nexports.default = { ciphers: ciphers, wrapKeys: wrapKeys };\n//# sourceMappingURL=params.js.map","\n/**\n * webapi.js\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decrypt = exports.encrypt = exports.unwrapKey = exports.wrapKey = void 0;\n/**\n * WebCrypto KeyWrapping function simply uses encrypt function.\n * @param keyToBeWrapped {Uint8Array} - plaintext key\n * @param wrappingKey {Uint8Array} - wrapping key\n * @param name {string} - 'AES-KW'\n * @param iv {Uint8Array} - default is '0xA6A6A6A6A6A6A6A6'\n * @param webCrypto {Object} - crypto.subtle object\n * @return {Uint8Array} - Unwrapped Key\n */\nvar wrapKey = function (keyToBeWrapped, wrappingKey, _a, webCrypto) {\n    var name = _a.name, iv = _a.iv;\n    return __awaiter(void 0, void 0, void 0, function () {\n        var kek, cek, data, e_1;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    _b.trys.push([0, 4, , 5]);\n                    return [4 /*yield*/, webCrypto.importKey('raw', wrappingKey, { name: name }, false, ['wrapKey', 'unwrapKey'])];\n                case 1:\n                    kek = _b.sent();\n                    return [4 /*yield*/, webCrypto.importKey('raw', keyToBeWrapped, { name: name }, true, ['wrapKey', 'unwrapKey'])];\n                case 2:\n                    cek = _b.sent();\n                    return [4 /*yield*/, webCrypto.wrapKey('raw', cek, kek, { name: name, iv: iv })];\n                case 3:\n                    data = _b.sent();\n                    return [2 /*return*/, new Uint8Array(data)];\n                case 4:\n                    e_1 = _b.sent();\n                    if (e_1 instanceof Error) {\n                        throw new Error(\"WebCrypto_FailedToWrapKey - \".concat(e_1.message));\n                    }\n                    else {\n                        throw new Error('WebCrypto_FailedToWrapKey');\n                    }\n                    return [3 /*break*/, 5];\n                case 5: return [2 /*return*/];\n            }\n        });\n    });\n};\nexports.wrapKey = wrapKey;\n/**\n * WebCrypto KeyUnwrapping function as well as keyWrapping\n * @param wrappedKey {Uint8Array} - Wrapped key\n * @param unwrappingKey {Uint8Array} - Key used for wrapping\n * @param name {string} - 'AES-KW'\n * @param iv {Uint8Array} - default is '0xA6A6A6A6A6A6A6A6'\n * @param webCrypto {Object} - crypto.subtle object\n * @return {Uint8Array} - Unwrapped Key\n */\nvar unwrapKey = function (wrappedKey, unwrappingKey, _a, webCrypto) {\n    var name = _a.name, iv = _a.iv;\n    return __awaiter(void 0, void 0, void 0, function () {\n        var kek, cek, _b, e_2;\n        return __generator(this, function (_c) {\n            switch (_c.label) {\n                case 0:\n                    _c.trys.push([0, 4, , 5]);\n                    return [4 /*yield*/, webCrypto.importKey('raw', unwrappingKey, { name: name }, false, ['wrapKey', 'unwrapKey'])];\n                case 1:\n                    kek = _c.sent();\n                    return [4 /*yield*/, webCrypto.unwrapKey('raw', wrappedKey, kek, { name: name, iv: iv }, { name: 'AES-GCM' }, true, ['encrypt', 'decrypt'])];\n                case 2:\n                    cek = _c.sent();\n                    _b = Uint8Array.bind;\n                    return [4 /*yield*/, webCrypto.exportKey('raw', cek)];\n                case 3: return [2 /*return*/, new (_b.apply(Uint8Array, [void 0, _c.sent()]))()];\n                case 4:\n                    e_2 = _c.sent();\n                    if (e_2 instanceof Error) {\n                        throw new Error(\"WebCrypto_FailedToUnwrapKey - \".concat(e_2.message));\n                    }\n                    else {\n                        throw new Error('WebCrypto_FailedToUnwrapKey');\n                    }\n                    return [3 /*break*/, 5];\n                case 5: return [2 /*return*/];\n            }\n        });\n    });\n};\nexports.unwrapKey = unwrapKey;\n/**\n * Encrypt data through AES of WebCrypto API.\n * @param {Uint8Array} msg - Plaintext message to be encrypted.\n * @param {Uint8Array} key - Byte array of symmetric key.\n * @param {String} name - Name of AES algorithm like 'AES-GCM'.\n * @param {Uint8Array} [iv] - Byte array of initial vector if required.\n * @param {Uint8Array} [additionalData] - Byte array of additional data if required.\n * @param {Number} [tagLength] - Authentication tag length if required.\n * @param {Object} webCrypto - WebCrypto object, i.e., window.crypto.subtle\n * @return {Promise<Uint8Array>} - Encrypted data byte array.\n * @throws {Error} - Throws if UnsupportedCipher.\n */\nvar encrypt = function (msg, key, _a, webCrypto) {\n    var _b = _a.name, name = _b === void 0 ? 'AES-GCM' : _b, iv = _a.iv, additionalData = _a.additionalData, tagLength = _a.tagLength;\n    return __awaiter(void 0, void 0, void 0, function () {\n        var encryptionConfig, sessionKeyObj, data, e_3;\n        return __generator(this, function (_c) {\n            switch (_c.label) {\n                case 0:\n                    encryptionConfig = setCipherParams({ name: name, iv: iv, additionalData: additionalData, tagLength: tagLength });\n                    _c.label = 1;\n                case 1:\n                    _c.trys.push([1, 4, , 5]);\n                    return [4 /*yield*/, webCrypto.importKey('raw', key, encryptionConfig, false, ['encrypt', 'decrypt'])];\n                case 2:\n                    sessionKeyObj = _c.sent();\n                    return [4 /*yield*/, webCrypto.encrypt(encryptionConfig, sessionKeyObj, msg)];\n                case 3:\n                    data = _c.sent();\n                    return [2 /*return*/, new Uint8Array(data)];\n                case 4:\n                    e_3 = _c.sent();\n                    if (e_3 instanceof Error) {\n                        throw new Error(\"WebCrypto_EncryptionFailure: \".concat(e_3.message));\n                    }\n                    else {\n                        throw new Error('WebCrypto_EncryptionFailure');\n                    }\n                    return [3 /*break*/, 5];\n                case 5: return [2 /*return*/];\n            }\n        });\n    });\n};\nexports.encrypt = encrypt;\n/**\n * Decrypt data through AES of WebCrypto API.\n * @param {Uint8Array} data - Encrypted message to be decrypted.\n * @param {Uint8Array} key - Byte array of symmetric key.\n * @param {String} name - Name of AES algorithm like 'AES-GCM'.\n * @param {Uint8Array} [iv] - Byte array of initial vector if required.\n * @param {Uint8Array} [additionalData] - Byte array of additional data if required.\n * @param {Number} [tagLength] - Authentication tag length if required.\n * @param {Object} webCrypto - WebCrypto object, i.e., window.crypto.subtle\n * @return {Promise<Uint8Array>} - Decrypted plaintext message.\n * @throws {Error} - Throws if UnsupportedCipher or DecryptionFailure.\n */\nvar decrypt = function (data, key, _a, webCrypto) {\n    var name = _a.name, iv = _a.iv, additionalData = _a.additionalData, tagLength = _a.tagLength;\n    return __awaiter(void 0, void 0, void 0, function () {\n        var decryptionConfig, sessionKeyObj, msg, e_4;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    decryptionConfig = setCipherParams({ name: name, iv: iv, additionalData: additionalData, tagLength: tagLength });\n                    _b.label = 1;\n                case 1:\n                    _b.trys.push([1, 4, , 5]);\n                    return [4 /*yield*/, webCrypto.importKey('raw', key, decryptionConfig, false, ['encrypt', 'decrypt'])];\n                case 2:\n                    sessionKeyObj = _b.sent();\n                    return [4 /*yield*/, webCrypto.decrypt(decryptionConfig, sessionKeyObj, data)];\n                case 3:\n                    msg = _b.sent();\n                    return [2 /*return*/, new Uint8Array(msg)];\n                case 4:\n                    e_4 = _b.sent();\n                    if (e_4 instanceof Error) {\n                        throw new Error(\"WebCrypto_DecryptionFailure: \".concat(e_4.message));\n                    }\n                    else {\n                        throw new Error('WebCrypto_DecryptionFailure');\n                    }\n                    return [3 /*break*/, 5];\n                case 5: return [2 /*return*/];\n            }\n        });\n    });\n};\nexports.decrypt = decrypt;\n/**\n * Set params for encryption algorithms.\n * @param {String} name - Name of AES algorithm like 'AES-GCM'.\n * @param {Uint8Array} [iv] - Byte array of initial vector if required.\n * @param {Uint8Array} [additionalData] - Byte array of additional data if required.\n * @param {Number} [tagLength] - Authentication tag length if required.\n */\nvar setCipherParams = function (_a) {\n    var name = _a.name, iv = _a.iv, additionalData = _a.additionalData, tagLength = _a.tagLength;\n    var alg = { name: name, iv: iv, additionalData: additionalData, tagLength: tagLength };\n    switch (name) {\n        case 'AES-GCM': {\n            alg.tagLength = tagLength * 8;\n            break;\n        }\n        case 'AES-CBC': {\n            break;\n        }\n        case 'AES-CTR': {\n            if (iv.length === 0 || iv.length > 16)\n                throw new Error('InvalidIVLength');\n            alg.counter = new Uint8Array(16);\n            alg.counter.set(iv);\n            alg.counter[15] += 1;\n            alg.length = 128; // todo: this might be  (16 - iv.length) * 8.\n            break;\n        }\n    }\n    return alg;\n};\n//# sourceMappingURL=webapi.js.map"]}